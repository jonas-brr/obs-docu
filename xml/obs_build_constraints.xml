<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter version="5.1" xml:id="cha.obs.build_constraints"
 xmlns="http://docbook.org/ns/docbook"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink" >
 <title>Build Constraints</title>
 <info/>
 <para> Using build constraints, one can define hardware and/or software
  requirements that the Build Service will then use to narrow down the pool
  of build workers that are qualified to build a particular project, package or
  repository.
 </para>
 <para> By setting appropriate build constraints, one can avoid situations
  in which builds fail due to insufficient memory or disk space, wrong kernel
  version, etc. </para>
 <sect1>
  <title>Setting constraints</title>
  <para> Constraints can be set for a particular package by including a
   _constraints file in the package. </para>
  <para> Constraints can also be included directly in the build recipe (spec,
   dsc, etc.), provided the build recipe parser supports it. </para>
  <warning>
   <para>It's not clear how the reader would find out if a given build recipe
    parser supports BuildConstraints and it would even be nice here to link to a
    discussion of what, specifically, is meant by "build recipe". </para>
  </warning>
  <para> Finally, constraints can be set on a project-wide basis by including
   <literal>Constraint</literal> directives in the project config. These can be
   guarded in various ways to make them apply only for certain architectures or
   certain repositories. </para>
  <sect2>
   <title>Setting constraints in a _constraints file</title>
   <para> Build constraints for a package are part of the package sources, as
    an XML source file called <literal>_constraints</literal>. If present, the Build
    Service will validate this file upon submission. Constraints files vary in 
    complexity, depending on how many constraints are being set and whether they 
    need to be set globally or on a per-architecture basis. </para>
   <para> Here is a simple example: </para>
   <screen>&lt;?xml version="1.0"?&gt;
&lt;constraints&gt;
  &lt;hardware&gt;
    &lt;physicalmemory&gt;
      &lt;size unit="M"&gt;2000&lt;/size&gt;
    &lt;/physicalmemory&gt;
    &lt;disk&gt;
      &lt;size unit="G"&gt;5&lt;/size&gt;
    &lt;/disk&gt;
  &lt;/hardware&gt;
  &lt;sandbox&gt;kvm&lt;/sandbox&gt;
  &lt;hostlabel exclude="true"&gt;SLOW_CPU&lt;/hostlabel&gt;
&lt;/constraints&gt;</screen>
   <para>See <xref linkend="_constraint_syntax"/> for a full treatment of
    constraint syntax.</para>
  </sect2>
  <sect2>
   <title>Setting constraints in build recipes</title>
   <para> Some build recipe parsers support parsing of constraints
    also from the build descriptions, e.g. in RPM spec files or Dockerfiles.
    Where supported, setting of constraints directly in build recipes
    is achieved by inserting "magic comment lines" with the
    format <literal>#!BuildConstraint: &lt;QUALIFIER&gt; &lt;VALUE&gt;</literal>
    directly in the file. Instead of specifying the qualifiers by nesting
    directives like in XML, colons are used. For example:
    </para>
   <screen>#!BuildConstraint: linux:version:min 3.0</screen>
   <para> In this example, "linux:version:min" is the constraint qualifier and
    "3.0" is the value. </para>
   <para>These lines can also be guarded with various conditionals, 
    for example to apply these only on some architectures, or only for specific
    multibuild flavors. </para>
   <warning>
    <para>Here we should link to a discussion of RPM conditionals</para>
   </warning>
   <para>See <xref linkend="_constraint_syntax"/> for a full treatment of
    constraint syntax.</para>
  </sect2>
  <sect2>
   <title>Setting constraints in project configuration</title>
   <para> Build constraints for an entire project, or for specific repositories
    within it, or for specific architectures within those repositories, are
    defined in the project config by adding lines as so: </para>
   <screen>Constraint: &lt;QUALIFIER&gt; &lt;VALUE&gt;</screen>
   <para> Colons are used to construct the QUALIFIER, just as when setting
    constraints in build recipes. For example: </para>
   <screen>Constraint: linux:version:min 3.0</screen>
   <para> In this example, "linux:version:min" is the constraint qualifier and
    "3.0" is the value. </para>
   <para> The project configuration supports <literal>%if</literal> guards, which
    can be used to make a constraint apply only to certain architectures or
    repositories. For example:</para>
   <screen>%ifarch ppc ppc64 ppc64le
Constraint: hardware:cpu:flag power8
%endif</screen>
   <para>or</para>
   <screen>%if "%_repository" == "images"
Constraint: hardware:disk:size unit=M 4000
%endif</screen>
   <para> Constraints defined in project config, _constraints file, and the build
    recipe are merged in this order. This means a constraint for the same topic 
    overwrites the one from the former location. </para>
   <para>Read on for a full treatment of constraint syntax.</para>
  </sect2>
 <sect1 xml:id="_constraint_syntax">
  <title>Constraint syntax</title>
  <para> In general, build constraints consist of a qualifier and a value.
   Qualifiers can either be set directly, such as <literal>hostlabel</literal> or
   consist of subqualifiers, as in the case of <literal>hardware</literal>.</para>
  <sect2>
   <title><literal>hostlabel</literal></title>
   <para> The "hostlabel" qualifier is any string which can be assigned to
    build workers when starting the <literal>bs_worker</literal> process. It can be
    used to restrict a build to specific workers, for example to run benchmarks
    in a reproducible way. This constraint can also be defined as a negative
    definition using the <literal>exclude=true</literal> attribute. However,
    the hostlabel is always specific to one OBS instance.  You should avoid it as
    much as possible, since building with this constraint in another instance is
    usually not possible. Use any of the other constraints if possible. </para>
   <para> Example for _constraints file:</para>
    <screen>&lt;constraints exclude="false"&gt;
   &lt;hostlabel&gt;benchmark_runner&lt;/hostlabel&gt;
&lt;/constraints&gt;</screen>
   <para>Example for project configuration:  </para>
   <screen>Constraint: hostlabel benchmark_runner</screen>
   <para>Example for rpm spec file or Dockerfile:</para>
   <screen>#!BuildConstraint: hostlabel benchmark_runner</screen>
 </sect1>
 <sect1>
  <title><literal>sandbox</literal></title>
  <para> Defines the sandbox which is used for the build. Sandboxes are
   chroot, Xen or KVM environments. There is also the virtual secure sandbox,
   which allows building on Xen or KVM. This constraints may also be defined as
   a negative definition via the <literal>exclude=true</literal> attribute. </para>
  <para> Example for <filename>_constraints</filename> file:</para>
   <screen>&lt;constraints exclude="true"&gt;
  &lt;sandbox&gt;secure&lt;/sandbox&gt;
&lt;/constraints&gt;</screen>
   <para>Example for project configuration:</para>
   <screen>Constraint: sandbox secure</screen>
   <para>Example for rpm spec file or Dockerfile:</para>
   <screen>#!BuildConstraint: hostlabel:benchmark_runner</screen>
 </sect1>
 <sect1>
  <title><literal>linux</literal></title>
  <para> The Linux kernel specific part. </para>
  <sect2>
   <title>version</title>
   <para> To require a specific Linux kernel version. </para>
   <para> Example for _constraints file:</para>
    <screen>&lt;constraints&gt;
  &lt;linux&gt;&lt;version&gt;
    &lt;min&gt;3.0&lt;/min&gt;
    &lt;max&gt;4.0&lt;/max&gt;
  &lt;/version&gt;&lt;/linux&gt;
&lt;/constraints&gt;</screen>
    <para>Example for project configuration:</para>
    <screen>Constraint: linux:version:min 3.0
Constraint: linux:version:max 4.0</screen>
   <para>Example for rpm spec file or Dockerfile:</para>
    <screen>#!BuildConstraint: linux:version:min 3.0
#!BuildConstraint: linux:version:max 4.0</screen>
   <sect3>
    <title><literal>min</literal></title>
    <para> Minimal kernel version. </para>
   </sect3>
   <sect3>
    <title><literal>max</literal></title>
    <para> Maximal kernel version. </para>
   </sect3>
  </sect2>
  <sect2>
   <title><literal>flavor</literal></title>
   <para> A specific kernel flavor like default or smp (from kernel packages
    kernel-default or kernel-smp). </para>
   <para> Example for _constraints file:</para>
    <screen>&lt;constraints&gt;
  &lt;linux&gt;
    &lt;flavor&gt;default&lt;/flavor&gt;
  &lt;/linux&gt;
&lt;/constraints&gt;</screen>
    <para>Example for project configuration:</para>
    <screen>Constraint: linux:flavor default</screen>
   <para>Example for rpm spec file or Dockerfile:</para>
    <screen>#!BuildConstraint: linux:flavor default</screen>
  </sect2>
 </sect1>
 <sect1>
  <title><literal>hardware</literal></title>
  <para> To require hardware or build instance features. </para>
  <sect2>
   <title><literal>cpu</literal></title>
   <para> To require a specific CPU feature. </para>
   <sect3>
    <title><literal>flag</literal></title>
    <para> CPU features which are provided by the hardware. On Linux they can
     be found in /proc/cpuinfo. The flag element may be used multiple times to
     require multiple CPU features. </para>
    <para> Example for _constraints file:</para>
     <screen>&lt;constraints&gt;
  &lt;hardware&gt;&lt;cpu&gt;
    &lt;flag&gt;mmx&lt;/flag&gt;
    &lt;flag&gt;sse2&lt;/flag&gt;
  &lt;/cpu&gt;&lt;/hardware&gt;
&lt;/constraints&gt;</screen>
     <para> Example for project configuration:</para>
     <screen>Constraint: hardware:cpu:flag mmx
Constraint: hardware:cpu:flag sse2</screen>
   <para>Example for rpm spec file or Dockerfile:</para>
     <screen>#!BuildConstraint: hardware:cpu:flag mmx
#!BuildConstraint: hardware:cpu:flag sse2</screen>
     <para>
      <literal>EL0</literal> is a special flag that that can be used on
      hardware that only supports level-0 exceptions, such as certain armv8l
      systems.
      This means that VMs or 32-bit kernels are not supported but userland is
      supported.
      This flag can be used to block builds on such hardware if no 64-bit
      kernel is available for a project.
     </para>
     <para>Example for project configuration:</para>
     <screen>Constraint: hardware:cpu:flag exclude=true EL0</screen>
     <para>Example for rpm spec file or Dockerfile:</para>
     <screen>#!BuildConstraint: hardware:cpu:flag exclude=true EL0</screen>
     <para>
      Additional flags are also reported for effective architecture level of
      the cpu. This includes the following flags:
      <itemizedlist>
        <listitem><para>power7</para></listitem>
        <listitem><para>power8</para></listitem>
        <listitem><para>power9</para></listitem>
        <listitem><para>x86-64-v2</para></listitem>
        <listitem><para>x86-64-v3</para></listitem>
        <listitem><para>x86-64-v4</para></listitem>
      </itemizedlist>
     </para>
   </sect3>
  </sect2>
  <sect2>
   <title><literal>processors</literal></title>
   <para>To require a minimal number of processors provided by the VM.</para>
   <para> Example for _constraints file:</para>
    <screen>&lt;constraints&gt;
  &lt;hardware&gt;
    &lt;processors&gt;4&lt;/processors&gt;
  &lt;/hardware&gt;
&lt;/constraints&gt;</screen>
    <para>Example for project configuration:</para>
    <screen>Constraint: hardware:processors 4</screen>
    <para>Example for rpm spec file or Dockerfile:</para>
    <screen>#!BuildConstraint: hardware:processors 4</screen>
  </sect2>
  <sect2>
   <title><literal>jobs</literal></title>
   <para> To require a minimal number of pre-confiured parallel jobs for the build. 
          This limits the parallel wanted jobs for the build tooling, but is actually not
          a hardware requirement.</para>
   <para> Example for _constraints file:</para>
    <screen>&lt;constraints&gt;
  &lt;hardware&gt;
    &lt;jobs&gt;4&lt;/jobs&gt;
  &lt;/hardware&gt;
&lt;/constraints&gt;</screen>
    <para>Example for project configuration:</para>
    <screen>Constraint: hardware:jobs 4</screen>
    <para>Example for rpm spec file or Dockerfile:</para>
    <screen>#!BuildConstraint: hardware:jobs 4</screen>
  </sect2>
  <sect2>
   <title><literal>disk</literal></title>
   <para> Hard disk specific. </para>
   <sect3>
    <title><literal>size</literal></title>
    <para> To require a minimal size of the disk. </para>
    <para> Example for _constraints file:</para>
     <screen>&lt;constraints&gt;
  &lt;hardware&gt;
    &lt;disk&gt;
      &lt;size unit="G"&gt;4&lt;/size&gt;
    &lt;/disk&gt;
  &lt;/hardware&gt;
&lt;/constraints&gt;</screen>
     <para>Example for project configuration:</para>
     <screen>Constraint: hardware:disk:size unit=G 4</screen>
     <para>Example for rpm spec file or Dockerfile:</para>
     <screen>#!BuildConstraint: hardware:disk:size unit=G 4</screen>
   </sect3>
  </sect2>
  <sect2>
   <title><literal>memory</literal></title>
   <para> Memory specific. </para>
   <sect3>
    <title><literal>size</literal></title>
    <para> To require a minimal memory size including swap space. </para>
    <para> Example for _constraints file:</para>
     <screen>&lt;constraints&gt;
  &lt;hardware&gt;
    &lt;memory&gt;
      &lt;size unit="M"&gt;1400&lt;/size&gt;
    &lt;/memory&gt;
  &lt;/hardware&gt;
&lt;/constraints&gt;</screen>
     <para> Example for project configuration:</para>
     <screen>Constraint: hardware:memory:size unit=M 1400</screen>
     <para>Example for rpm spec file or Dockerfile:</para>
     <screen>#!BuildConstraint: hardware:memory:size unit=M 1400</screen>
   </sect3>
  </sect2>
  <sect2>
   <title><literal>physicalmemory</literal></title>
   <para> Memory specific. </para>
   <sect3>
    <title><literal>size</literal></title>
    <para> To require a minimal memory size. Swap space is not taken into
     account here. </para>
    <para> Example for _constraints file:</para>
     <screen>&lt;constraints&gt;
  &lt;hardware&gt;
    &lt;physicalmemory&gt;
      &lt;size unit=M&gt;1400&lt;/size&gt;
    &lt;/physicalmemory&gt;
  &lt;/hardware&gt;
&lt;/constraints&gt;</screen>
     <para>Example for project configuration: </para>
     <screen>Constraint: hardware:physicalmemory:size unit=M 1400</screen>
     <para>Example for rpm spec file or Dockerfile:</para>
     <screen>#!BuildConstraint: hardware:physicalmemory:size unit=M 1400</screen>
   </sect3>
  </sect2>
 </sect1>
  <title>Constraint Handling</title>
  <sect2>
   <title>What happens when workers fail to meet the constraints</title>
   <para> If no build worker meets the constraints, the package will turn to
    a failed state. See also ... for a discussion of how the scheduler's behavior
    differs according to how many build workers meet the defined constraints. </para>
  </sect2>
 <sect1>
  <para> The constraint handling depends on what is met by the restrictions.
   The handling starts when there is no worker to fulfill the constraints. </para>
  <sect2>
   <title>More than half of the workers satisfy the constraints</title>
   <para> The build will just stay in state scheduled and no further notification
    is set. </para>
  </sect2>
  <sect2>
   <title>Less than Half of the Workers Satisfy the Constraints</title>
   <para> The build will stay in state scheduled and the dispatch details are set
    to tell the user that this build can take a long time to complete. This will
    be shown in the Web UI on mouse over and the scheduled state will be
    highlighted as well.</para>
    <screen>waiting for 4 compliant workers (4 down)</screen> 
   <para>The <command>(4
     down)</command> means that 4 of the 4 compliant workers are down and that
    someone should have a look. </para>
  </sect2>
  <sect2>
   <title>No Workers Satisfy the Constraints</title>
   <para> If no worker can handle the constraints defined by the package or
    project, the build fails. There is also a hint in the build log what has
    failed.</para>
    <screen>package build was not possible:

no compliant workers (constraints mismatch hint: hardware:processors sandbox)

Please adapt your constraints.</screen>
  </sect2>
 </sect1>
 <sect1>
  <title>Checking Constraints with &osccmd;</title>
  <para> You can check the constraints of a project / package with the osc
   tool. You have to be in an osc working directory.</para>
   
   <screen><command>osc checkconstraints [OPTS] REPOSITORY ARCH CONSTRAINTSFILE</command></screen>
   <para>Either you give a repository and an arch or osc will check the constraints
   for all repository / arch pairs for the package. A few examples:</para>
   <screen><command># osc checkconstraints</command>
Repository                Arch                      Worker
----------                ----                      ------
openSUSE_Leap_42.2        x86_64                    1
openSUSE_Leap_42.1        x86_64                    1</screen>
   <para>If no file is given it takes the local _constraints file. If this file does
   not exist or the --ignore-file switch is set only the project constraints
   are used.</para>
   <screen><command># osc checkconstraints openSUSE_Leap_42.1 x86_64</command>
Worker
------
x86_64:worker:1
x86_64:worker:2</screen>
   <para>If a repository and an arch is given a list of compliant workers is
   returned. </para>
  <para> Another command to verify a worker and display the worker information
   is osc workerinfo. </para>
  <screen>&lt;worker hostarch="x86_64" registerserver="http://localhost:5252" workerid="worker:1"&gt;
  &lt;hostlabel&gt;MY_WORKER_LABEL_1&lt;/hostlabel&gt;
  &lt;sandbox&gt;chroot&lt;/sandbox&gt;
  &lt;linux&gt;
    &lt;version&gt;4.1.34-33&lt;/version&gt;
    &lt;flavor&gt;default&lt;/flavor&gt;
  &lt;/linux&gt;
  &lt;hardware&gt;
    &lt;cpu&gt;
      &lt;flag&gt;fpu&lt;/flag&gt;
      &lt;flag&gt;vme&lt;/flag&gt;
      &lt;flag&gt;de&lt;/flag&gt;
    &lt;/cpu&gt;
    &lt;processors&gt;2&lt;/processors&gt;
    &lt;jobs&gt;1&lt;/jobs&gt;
  &lt;/hardware&gt;
&lt;/worker&gt;</screen>
  <para> It returns the information of the desired worker. </para>
 </sect1>
</chapter>
